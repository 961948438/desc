<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> UDP_TCP_protocol · f_x_y</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="UDP_TCP_protocol - xiangyou fu"><meta name="keywords"><meta name="author" content="xiangyou fu"><link rel="short icon" href="https://fuxiangyou1.gitee.io/medias/log.png"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.innerjquery.club/atom.xml" title="f_x_y"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="f_x_y" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://bpic.588ku.com/element_pic/20/06/30/7c7f9a4c26c463c5dfd5380c7e8faa47.jpg!/fw/253/quality/90/unsharp/true/compress/true"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">UDP_TCP_protocol</h1><div class="post-info">2019-12-30<p class="visit"><i data-identity="2019/12/30/UDP_TCP_protocol/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h3 id="一-内容大纲"><a href="#一-内容大纲" class="headerlink" title="一. 内容大纲"></a>一. 内容大纲</h3><ol>
<li>C/S B/S架构</li>
<li>网络通信原理</li>
<li>osi七层协议<ul>
<li>简单串联五层协议以及作用</li>
<li>对五层协议详细的补充说明</li>
</ul>
</li>
<li>UDP TCP 协议</li>
<li>TCP协议的三次握手和四次挥手</li>
<li>socket套接字</li>
<li>基于TCP协议的socket简单的网络通信(待定)</li>
</ol>
<h3 id="二-具体内容"><a href="#二-具体内容" class="headerlink" title="二. 具体内容"></a>二. 具体内容</h3><h4 id="1-C-S-B-S架构"><a href="#1-C-S-B-S架构" class="headerlink" title="1. C/S B/S架构"></a>1. C/S B/S架构</h4><p>  C: client端</p>
<p>  B: browse 浏览器</p>
<p>  S: server端</p>
<p>  C/S架构: 基于客户端与服务端之间的通信</p>
<ul>
<li><p>​QQ, 游戏,皮皮虾, 快手,抖音.</p>
</li>
<li><p>​优点: 个性化设置,响应速度快,</p>
</li>
<li><p>缺点: 开发成本,维护成本高,占用空间,用户固定.</p>
<p>B/S架构: 基于浏览器与服务端之间的通信</p>
</li>
<li><p>谷歌浏览器,360浏览器,火狐浏览器等等.</p>
</li>
<li><p>优点: 开发维护成本低,占用空间相对低,用户不固定.</p>
</li>
<li><p>​缺点: 功能单一,没有个性化设置,响应速度相对慢一些.</p>
</li>
</ul>
<h4 id="2-网络通信原理"><a href="#2-网络通信原理" class="headerlink" title="2. 网络通信原理"></a>2. 网络通信原理</h4><p>  80年代,固定电话联系,(还没有推广普通话)</p>
<p>  1.两台电话之间一堆物理连接介质连接.<br>  2.拨号,锁定对方电话的位置.</p>
<p>  由于当时没有统一普通话,所以你如果和河南,山西,广西,福建等朋友进行友好的沟通交流,你必须学当地的方言.</p>
<p>  推广普通话,统一交流方式.</p>
<ol>
<li><p>两台电话之间一堆物理连接介质连接.</p>
</li>
<li><p>拨号,锁定对方电话的位置.</p>
</li>
<li><p>统一交流方式.</p>
<p>全球范围内交流:</p>
</li>
<li><p>两台电话之间一堆物理连接介质连接.</p>
</li>
<li><p>拨号,锁定对方电话的位置.</p>
</li>
<li><p>统一交流方式.(英语)</p>
<p>话题转回互联网通信:</p>
<p>我现在想和美国的一个girl联系.你如何利用计算机联系???</p>
</li>
<li><p>两台计算机要有一堆物理连接介质连接.</p>
</li>
<li><p>找到对方计算机软件位置.</p>
</li>
<li><p>遵循一揽子互联网通信协议.</p>
</li>
</ol>
<h4 id="3-osi七层协议"><a href="#3-osi七层协议" class="headerlink" title="3. osi七层协议"></a>3. osi七层协议</h4><p>  <img src="https://fuxiangyou1_admin.gitee.io/image/image/1565663997237.png" alt="1565663997237"></p>
<h5 id="简单串联五层协议以及作用"><a href="#简单串联五层协议以及作用" class="headerlink" title="简单串联五层协议以及作用"></a>简单串联五层协议以及作用</h5><ol>
<li><p><strong>物理层</strong></p>
<p>物理层指的就是网线,光纤,双绞线等等物理连接介质</p>
<p>物理层发送的是比特流: 01010101010101010101只是发送比特流有什么问题???</p>
<p>数据应该有规律的分组,分组是数据链路层做的事情.</p>
</li>
<li><p><strong>数据链路层</strong></p>
<p>数据链路层对比特流进行分组.</p>
<p>最开始从事互联网企业的就是美国的几家公司,各家有各家自定的分组标准.后来统一了标准: 对数据分组的标准.</p>
<p><strong>以太网协议</strong>: 对比特流进行合理的分组.</p>
<p>一组数据01010101 叫做一帧,数据报.</p>
<p>head  |  data(晚上约么)</p>
<p>head是固定的长度:18个字节</p>
<ul>
<li><p>源地址: 6个字节    </p>
</li>
<li><p>目标地址: 6个字节 </p>
</li>
<li><p>数据类型: 6个字节</p>
</li>
</ul>
<p>data: 最少是46个字节,最大1500字节.</p>
<p>一帧数据: 最少64个字节,最大1518个字节.</p>
<p>一帧数据|一帧数据……</p>
<p>每个电脑上都有一个网卡,往卡上都记录一个独一无二的地址.</p>
<p><strong>mac地址</strong>: 就是你的计算机上网卡上标注的地址.</p>
<p>12位16进制数组成 :前六位是厂商编号,后六位是流水线号.</p>
<p>源mac地址 目标mac地址 数据类型 | data</p>
<p>‘1C-1B-0D-A4-E6-44’</p>
<p>计算机的通信方式:</p>
<p>同一个局域网内,通过广播的形式通信.</p>
<p>消息一经广播发出,村里所有的人(局域网所有的计算机都能接收到消息,分析消息,是否是找我的,不是就丢弃),</p>
<p><img src="/.club//课上笔记\assets\1565666245241.png" alt="1565666245241"></p>
<p>计算机只能在局域网内进行广播: 范围大了 广播风暴,效率极低.</p>
<p>以太网协议：对比特流进行分组，一组数据也叫做一帧，或者一个数据报<br>head | data(“你好！”)<br>head是固定长度的18个字节<br>源地址： 6个字节<br>目标地址：6个字节<br>数据类型：6个字节<br>data最少是46个字节，最大时1518个字节<br>一帧数据最少是64个字节，最大是1518个字节，<br>每一个电脑上都有一个网卡，网卡上记录中一个独一无二的地址这个地址就是mac地址：<br>mac地址就是我们计算机上网络标注的地址，由12位16进制的数组成，前六位是厂商编号，后六位是流水线<br>号；比如：”1C-1B-0D-A4-E6-44”<br>计算机的通讯方式：</p>
<ul>
<li>同一个局域网内，通过广播的形式通信<br>局域网所有的计算机都能接收消息，分析消息，判断是否找本机的<br>同一局域网内：mac地址 +我们的广播就可以通讯了</li>
</ul>
<p>还有两个没有解决:</p>
<ol>
<li>不同局域网如何通信?</li>
<li>软件与软件的通信,而不是计算机之间的通信.</li>
</ol>
</li>
<li><p>网络层</p>
<p><strong>IP协议</strong>: 确定局域网(子网)的位置.</p>
<p>找到具体软件的位置,上一层的事情</p>
</li>
<li><p>传输层:</p>
<p><strong>TCP端口协议</strong>: 确定软件在计算机的位置</p>
</li>
<li><p>应用层:</p>
<p>自己定义的协议.</p>
<ul>
<li>广播(局域网内) + mac地址(计算机位置) + ip(局域网的位置) + 端口(软件在计算机的位置)</li>
</ul>
<p>有了以上四个参数:你就可以确定世界上任何一个计算机的软件的位置.</p>
</li>
</ol>
<h5 id="对五层协议详细的补充说明"><a href="#对五层协议详细的补充说明" class="headerlink" title="对五层协议详细的补充说明"></a>对五层协议详细的补充说明</h5><p>  <img src="https://fuxiangyou1_admin.gitee.io/image/image/1565669367550.png" alt="1565669367550"></p>
<ol>
<li><p><strong>数据链路层补充</strong>:</p>
<p>同一个局域网通过广播的形式发送数据.</p>
<p>交换机的mac地址学习功能:</p>
<p>一个交换机的5个接口: 5个计算机.</p>
<p>1: FF-FF-FF-FF-FF-FF</p>
<p>2: FF-FF-FF-FF-FF-FF广播(局域网内) + mac地址(计算机位置) + ip(局域网的位置) + 端口(软件在计算机的位置)</p>
<p>有了以上四个参数:你就可以确定世界上任何一个计算机的软件的位置.</p>
<p>3: FF-FF-FF-FF-FF-FF</p>
<p>4: FF-FF-FF-FF-FF-FF</p>
<p>5: FF-FF-FF-FF-FF-FF</p>
<p>接口1:  源mac 1C-1B-0D-A4-E6-44 目标1C-1C-0D-A4-E5-44 |数据 以广播的形式发出</p>
<p>2,3,4,5口都会接收到消息,5口是最终的目标地址,交换机就会将5口与mac地址对应上.</p>
<p>1: 1C-1B-0D-A4-E6-44</p>
<p>2: FF-FF-FF-FF-FF-FF</p>
<p>3: FF-FF-FF-FF-FF-FF</p>
<p>4: FF-FF-FF-FF-FF-FF</p>
<p>5: 1C-1C-0D-A4-E5-44</p>
<p>当五个口都对应上具体的mac地址,2口再次发消息,就不会广播了,就会以单播发送.</p>
<p>我们的前提是什么? 你必须知道对方的mac地址你才可以以广播的形式发消息.实际上,网络通信中,你只要知道对方的IP与自己的IP即可.</p>
</li>
<li><p><strong>网络层</strong>:</p>
<p>IP协议: </p>
<p>ip地址:四段分十进制 192.168.0.12  </p>
<p>取值范围 0<del>255.0</del>255.0<del>255.0</del>255</p>
<p>子网掩码: C类子网掩码: 255.255.255.0</p>
<p>ip地址 + 子网掩码 按位与运算 计算出是否在统一局域网(子网,网段).</p>
<p>计算172.16.10.1 与 172.16.10.128</p>
<p>172.16.10.1：10101100.00010000.00001010.00000001</p>
<p>255.255.255.0:   11111111.11111111.11111111.00000000</p>
<p>从属于的局域网: 172.16.10.0</p>
<p>172.16.10.128：10101100.00010000.00001010.10000000</p>
<p>255.255.255.0:   11111111.11111111.11111111.00000000</p>
<p>从属于的局域网: 172.16.10.0</p>
<p>172.16.10.1 ~172.16.10.255</p>
<p>C类子网掩码 一个网段最多可以承载多个IP地址? 255 -3个ip地址</p>
<p>比如：192.168.254.1：被占用  192.168.254.255广播地址被占用，<br>192.168.254.1被占用</p>
<p>172.16.10.0 被占用.</p>
<p>172.16.10.255 广播地址 被占用.</p>
<p>172.16.10.1 被占用.</p>
<p>253台计算机.</p>
<p>如果你要想给另一个计算机发数据, 你一定要知道对方的ip地址.</p>
<p><strong>ARP协议</strong>:通过对方的ip地址获取到对方的mac地址.</p>
<p><img src="https://fuxiangyou1_admin.gitee.io/image/image/1565672211559.png" alt="1565672211559"></p>
<p>源码mac  目标mac   源IP    目标IP    数据</p>
<p>1C-1B-0D-A4-E6-44  FF:FF:FF:FF:FF:FF 172.16.10.13 172.16.10.156    数据</p>
<p>第一次发消息: 发送到交换机 —&gt; 路由器  广播的形式发出去</p>
<p>目标计算机收到消息:就要回消息:</p>
<p>源码mac  目标mac   源IP    目标IP    数据</p>
<p>1B-1B-0D-A4-E6-54  1C-1B-0D-A4-E6-44 172.16.10.156 172.16.10.13    数据<br>总结:<br>前提:知道目标mac:</p>
<p>计算机A 发送一个消息给 计算机B </p>
<p>源码mac  目标mac   源IP    目标IP    数据</p>
<p>单播的形式发送到交换机,交换机会检测自己的对照表有没有目标mac,如果有,单播传.如果没有,交由上一层: 路由器:</p>
<p>路由器收到消息: 对消息进行分析: </p>
<p>要确定目标计算机与本计算机是否在同一网段,</p>
<p>如果在同一网段,直接发送给对应的交换机,交换机在单播发给目标mac.</p>
<p>如果不是在同一网段: ?</p>
<p>前提:不知道目标mac:</p>
<p>计算机A 发送一个消息给 计算机B </p>
<p>源码mac  目标mac不知道   源IP    目标IP    数据</p>
<p>单播的形式发送到交换机,交换机交由上一层路由器:路由器收到消息: 对消息进行分析: </p>
<p>要确定目标计算机与本计算机是否在同一网段,</p>
<p>如果在同一网段通过 IP以及ARP协议获取到对方的mac地址,然后在通信.</p>
<p>如果不是在同一网段: ?</p>
<p><img src="https://fuxiangyou1_admin.gitee.io/image/image/1565673282900.png" alt="1565673282900"></p>
</li>
<li><p><strong>传输层</strong>:</p>
<p>端口协议:  UDP协议,TCP协议</p>
<p>65535端口</p>
<p>1~1024操作系统专门使用的端口</p>
<p>举例: 3306 数据库</p>
<p>自己开发软件都是8080以后的端口号</p>
</li>
</ol>
<h4 id="4-UDP-TCP-协议"><a href="#4-UDP-TCP-协议" class="headerlink" title="4. UDP TCP 协议"></a>4. <strong>UDP TCP 协议</strong></h4><p>  TCP（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、流式协议, 传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；文件传输程序。</p>
<p>  UDP（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文(数据包)，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。</p>
<h4 id="5-TCP协议的三次握手和四次挥手"><a href="#5-TCP协议的三次握手和四次挥手" class="headerlink" title="5. TCP协议的三次握手和四次挥手"></a>5. <strong>TCP协议的三次握手和四次挥手</strong></h4><p>  <img src="https://fuxiangyou1_admin.gitee.io/image/image/1565684713514.png" alt="1565684713514"></p>
<p>  <img src="https://fuxiangyou1_admin.gitee.io/image/image/1565685048174.png" alt="1565685048174"></p>
<p>  <img src="https://fuxiangyou1_admin.gitee.io/image/image/1565685723209.png" alt="1565685723209"></p>
<p>  注意：三次握手的过程中间两次可以合并，而四次挥手时中间两层不能合并的原因<br>  可能服务器端还有正在向客户端发送的数据，为了保证数据的完整性服务器回先发送完<br>  这些数据；所以这两次挥手的过程不能合并：</p>
<p>  syn洪水攻击:制造大量的假的无效的IP请求服务器.致使正常的IP访问不了服务器.</p>
<h4 id="6-socket套接字"><a href="#6-socket套接字" class="headerlink" title="6. socket套接字"></a>6. socket套接字</h4><h4 id="7-基于TCP协议的socket简单的网络通信-待定"><a href="#7-基于TCP协议的socket简单的网络通信-待定" class="headerlink" title="7. 基于TCP协议的socket简单的网络通信(待定)"></a>7. 基于TCP协议的socket简单的网络通信(待定)</h4></div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2020/01/12/python-logging%E6%A8%A1%E5%9D%97/" title="python_logging模块" class="prev">PREV</a><a href="/2019/12/23/socket%E5%8E%9F%E7%90%86/" title="socket原理" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2021 <a target="_blank">xiangyou fu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>