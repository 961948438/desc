<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> web前端面试题 · f_x_y</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="web前端面试题 - xiangyou fu"><meta name="keywords"><meta name="author" content="xiangyou fu"><link rel="short icon" href="https://fuxiangyou1.gitee.io/medias/log.png"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.innerjquery.club/atom.xml" title="f_x_y"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="f_x_y" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://bpic.588ku.com/element_pic/20/06/30/7c7f9a4c26c463c5dfd5380c7e8faa47.jpg!/fw/253/quality/90/unsharp/true/compress/true"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">web前端面试题</h1><div class="post-info">2021-03-14<p class="visit"><i data-identity="2021/03/14/web前端面试题/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h3 id="一、原生js和Jquery"><a href="#一、原生js和Jquery" class="headerlink" title="一、原生js和Jquery"></a>一、原生js和Jquery</h3><h4 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1.面向对象和面向过程的区别"></a>1.面向对象和面向过程的区别</h4><ol>
<li>js是面向过程还是面向过程？一直以来，顶级大师各有各的说法，这里不敢妄加评论。<br>面向过程就是函数式编程，按照传统流程编写一个又一个的函数来解决需求的方式。<br>面向过程适合一个人的项目，如果是团队合作，别人想修改你的代码就不利于维护了。所以下面着重聊聊面向对象。</li>
<li>面向对象就是讲你的需求抽象成一个对象，然后针对这个对象分析其属性和方法。<br>面向对象的主要特点就是封装，继承，多态。</li>
</ol>
<h4 id="2-this指向"><a href="#2-this指向" class="headerlink" title="2. this指向"></a>2. this指向</h4><p>  指向this所在的函数或者方法的调用者/拥有者;</p>
<h4 id="3-eval函数的用法"><a href="#3-eval函数的用法" class="headerlink" title="3. eval函数的用法"></a>3. eval函数的用法</h4><p>  将eval中的字符串作为表达式去使用；使用场景多在模块化规范中比如老版本的requirejs<br>  require将加载到的内容eval(content)去执行，<br>  计时器也支持eval，他会将其内容作为表达式去使用；<br>  window.setTimeout(“alert(0)”,5000)  计时器也支持eval，他会将其内容作为表达式去使用；<br>  在严格模式(“use strict”)下：eval(“var a=1;alert(a+=111)”)   eval有自己的作用域即当前字符串内</p>
<h4 id="4-算法：函数防抖"><a href="#4-算法：函数防抖" class="headerlink" title="4. 算法：函数防抖"></a>4. 算法：函数防抖</h4><p>  函数的防抖就是固定的时间内反复触发事件只执行下一个（即删除前一个事件），<br>  函数的防抖就是限制函数执行的速度/次数，比如滚动滚动条事件触发的次数非常多，但是我们并不想频繁执行<br>  事件处理函数，处理方式通常由：</p>
<ul>
<li>设置时间间隔，延迟指定时间执行，指定时间内执行我们return取消掉；</li>
<li>每一次时间触发的时候我们把上一次事件取消掉；</li>
<li>利用延迟器</li>
</ul>
<h4 id="5-算法：函数的节流"><a href="#5-算法：函数的节流" class="headerlink" title="5. 算法：函数的节流"></a>5. 算法：函数的节流</h4><p>  函数的节流就是限制函数执行的频率，即单位时间内执行的频率固定（即不执行下一个事件）；<br>  处理逻辑就是让短时间内只执行指定次数的函数；</p>
<h4 id="6-函数的柯里化"><a href="#6-函数的柯里化" class="headerlink" title="6. 函数的柯里化"></a>6. 函数的柯里化</h4><p>  函数的柯里化：函数的多参变成单参 比如 </p>
  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f(a) {</span><br><span class="line">return  function(b){</span><br><span class="line">  return function(c){</span><br><span class="line">    a+b+c</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  把f(1,2,3)  = 6 变成 f(1)(2)(3)</p>
<h4 id="7-作用域链"><a href="#7-作用域链" class="headerlink" title="7. 作用域链"></a>7. 作用域链</h4><ol>
<li><p>js中万物接对象，是对象就有一定的属性和方法；</p>
</li>
<li><p>如下中的func方法是全局变量是保存在window下的，那局部变量num和ff是保存在哪里呢<br>就是保存在哪个作用域对象下的，实际上是作用域对象.ff()调用了我们的ff方法</p>
</li>
<li><p>所谓产生一个作用域就是创建了一个作用域对象，将来作用对象里的变量将保存在其作用域对象下：</p>
</li>
<li><p>每一个产生作用域就会创建一个作用域对象；</p>
</li>
<li><p>当我们需要访问我们变量的时候，就会在我们当前作用域对象下去找我们的变量，如果没有<br>就会找上一级的作用域对象上去找我们的变量，直到找到顶层作用域对象window上，这个变量的查找<br>链就是我们的作用域链；</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function func(){</span><br><span class="line">  var mum = 1</span><br><span class="line">  function ff(){</span><br><span class="line">    console.log(mum)</span><br><span class="line">  }</span><br><span class="line">  ff()</span><br><span class="line">}</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h4 id="8-原型链的继承机制"><a href="#8-原型链的继承机制" class="headerlink" title="8. 原型链的继承机制"></a>8. 原型链的继承机制</h4><ol>
<li>默认的继承机制是prototype</li>
<li>JavaScript 中没有类的概念的，主要通过原型链来实现继承。通常情况下，继承意味着复制操作，然而 JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联（原型对象指针），这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些</li>
<li>当我们 new 了一个新的对象实例，明明什么都没有做，就直接可以访问 toString 、valueOf 等原生方法。那么这些方法是从哪里来的呢？答案就是原型<br><img src="https://img-blog.csdnimg.cn/20201029013612152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAyMTk4Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="1"></li>
<li>在控制台打印一个空对象时，我们可以看到，有很多方法，已经“初始化”挂载在内置的 proto 对象上了。这个内置的 proto 是一个指向原型对象的指针，它会在创建一个新的引用类型对象时（显示或者隐式）自动创建，并挂载到新实例上。当我们尝试访问实例对象上的某一属性 / 方法时，如果实例对象上有该属性 / 方法时，就返回实例属性 / 方法，如果没有，就去 proto 指向的原型对象上查找对应的属性 / 方法。这就是为什么我们尝试访问空对象的 toString 和 valueOf 等方法依旧能访问到的原因，JavaScript 正式以这种方式为基础来实现继承的。</li>
<li>构造函数: 如果说实例的 proto 只是一个指向原型对象的指针，那就说明在此之前原型对象就已经创建了，那么原型对象是什么时候被创建的呢？这就要引入构造函数的概念。其实构造函数也就只是一个普通的函数而已，如果这个函数可以使用 new 关键字来创建它的实例对象，那么我们就把这种函数称为 构造函数。</li>
<li>原型对象正是在构造函数被声明时一同创建的。构造函数被申明时，原型对象也一同完成创建，然后挂载到构造函数的 prototype 属性上：原型对象被创建时，会自动生成一个 constructor 属性，指向创建它的构造函数。这样它俩的关系就被紧密地关联起来了。<br>细心的话，你可能会发现，原型对象也有自己的 proto ，这也不奇怪，毕竟万物皆对象嘛。原型对象的 proto 指向的是 Object.prototype。那么 Object.prototype.proto 存不存在呢？其实是不存在的，打印的话会发现是 null 。这也证明了 Object 是 JavaScript 中数据类型的起源</li>
<li>原型及构造函数的大概关系了，我们可以用一张图来表示这个关系<br><img src="https://img-blog.csdnimg.cn/20201029014306353.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzAyMTk4Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="2"></li>
<li>原型链 说完了原型，就可以来说说原型链了，如果理解了原型机制，原型链就很好解释了。其实上面一张图上，那条被 proto 链接起来的链式关系，就称为原型链。原型链的作用：原型链如此的重要的原因就在于它决定了 JavaScript 中继承的实现方式。当我们访问一个属性时，查找机制如下：<ul>
<li>访问对象实例属性，有则返回，没有就通过 proto 去它的原型对象查找。</li>
<li>原型对象找到即返回，找不到，继续通过原型对象的 proto 查找。</li>
<li>一层一层一直找到 Object.prototype ，如果找到目标属性即返回，找不到就返回 undefined，不会再往下找，因为在往下找 proto 就是 null 了。</li>
</ul>
</li>
<li>通过上面的解释，对于构造函数生成的实例，我们应该能了解它的原型对象了。JavaScript 中万物皆对象，那么构造函数肯定也是个对象，是对象就有 proto ，那么构造函数的 proto 是什么？ object<br><img src="https://img-blog.csdnimg.cn/20201029014520887.jpg#pic_center" alt="3"></li>
</ol>
<h4 id="9-js的垃圾回收机制"><a href="#9-js的垃圾回收机制" class="headerlink" title="9. js的垃圾回收机制"></a>9. js的垃圾回收机制</h4><ol start="0">
<li>js的垃圾回收器是定期扫描的；</li>
<li>即变量的回收</li>
<li>算法1就是引用计数法，给每个变量上做上标记，有人要用就标记加1，不停的加一<br>当要用的人不用的时候标记就减一，js会不断扫描我们的内存检查我们的变量，缺点就是产生了很多<br>碎片</li>
<li>算法2.就是复制整理法</li>
<li></li>
</ol>
<h4 id="10-引起内存泄漏的常见方法"><a href="#10-引起内存泄漏的常见方法" class="headerlink" title="10. 引起内存泄漏的常见方法"></a>10. 引起内存泄漏的常见方法</h4><ol>
<li>闭包，</li>
<li>计时器</li>
<li>dom操作比如 let btn = $(“#btn”) ; btn.remove();<br>此时dom元素还是存在内存中的； </li>
</ol>
<h4 id="11-展开运算符-…"><a href="#11-展开运算符-…" class="headerlink" title="11. 展开运算符(…)"></a>11. 展开运算符(…)</h4><h4 id="12-promise对象"><a href="#12-promise对象" class="headerlink" title="12. promise对象"></a>12. promise对象</h4><ol>
<li><p>普通用法：来实现异步操作：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(eval("var a=10000;a"))</span><br><span class="line">  let pro = new Promise(function(res,rej){</span><br><span class="line">    res(1)</span><br><span class="line">  })</span><br><span class="line">  pro.then(function(result){</span><br><span class="line">    console.log(result)</span><br><span class="line">  }).catch(function(res){</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>链式加载</p>
</li>
<li><p>all方法获取到所有的返回值,且方法里的三个异步组是并列开跑的，all方法是所有的跑完了才执行then<br>而Promise.race(promise对象1,promise对象2，promise对象3).then(function(r){alert(r)})<br>race()方法有个特点，只要有一个promise对象完成，就会调用我们的then，也就是说，then只会拿到第一个执行<br>完成的结果；</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function apromise(a=1){</span><br><span class="line">  return new Promise(function(res,rej){</span><br><span class="line">    res(a+1)</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line">console.log(eval("var a=1000110;a"))</span><br><span class="line">Promise.all([apromise(1),apromise(2),apromise(3)])</span><br><span class="line">.then(function(list){</span><br><span class="line">  console.log(list)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h4 id="13-数组的方法：map，flatmap，reduce方法"><a href="#13-数组的方法：map，flatmap，reduce方法" class="headerlink" title="13. 数组的方法：map，flatmap，reduce方法"></a>13. 数组的方法：map，flatmap，reduce方法</h4><ol>
<li><p>map用于处理我们数组返回一个新数组,返回的数组长度和原长度一样，</p>
</li>
<li><p>但是flatmap方法会将返回的对象比如元组扁平化，原返回[[1,2,3],[1,2,3],3]会将扁平化<br>为[1,2,3,1,2,3,3]</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3]</span><br><span class="line">  new_arr =  arr.map(function(r,b,c){</span><br><span class="line">    console.log(r,b,c)</span><br><span class="line">    return [r,r**r,r**r*r]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>reduce函数常用于累积计算<br>注意它会遍历数组length(all) -1次，因为第一次会拿到两个数组中的值，<br>后面遍历将会只拿一个参数，其回调函数的第一个参数是上一次返回的值</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4,5,6,7]</span><br><span class="line">  nall =  arr.reduce(function(a,b,c){</span><br><span class="line">    console.log(a,b,c)</span><br><span class="line">    return a+b</span><br><span class="line">  })</span><br><span class="line">  console.log(nall)</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h4 id="14-浅拷贝和深拷贝"><a href="#14-浅拷贝和深拷贝" class="headerlink" title="14. 浅拷贝和深拷贝"></a>14. 浅拷贝和深拷贝</h4><ol>
<li><p>浅拷贝，只拷贝对象的第一层，深层次的对象的属性和方法拷贝其引用</p>
</li>
<li><p>方法： 遍历、</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = {a:1,b:2,c:{d:10,e:30}}</span><br><span class="line"></span><br><span class="line">  var obj1 = {}</span><br><span class="line"></span><br><span class="line">  var obj2 = {}</span><br><span class="line"></span><br><span class="line">  for (var item in obj){</span><br><span class="line">    obj1[item] = obj[item]</span><br><span class="line">  }</span><br><span class="line">  Object.assign(obj2,obj)</span><br><span class="line">  obj.a = 2</span><br><span class="line">  obj.c.d=11111</span><br><span class="line">  console.log(obj)</span><br><span class="line">  console.log(obj1)</span><br><span class="line">  console.log(obj2)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>浅拷贝、深拷贝的方法  使用json序列化对象处理我们的对象获取一个新完全的对象(深拷贝)</p>
<ol>
<li><p>但是这样存在一些问题，比如一些set,get等方法，或者后面动态添加的方法丢失，也不是完全的拷贝</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = {a:1,b:2,c:{d:10,e:30}}</span><br><span class="line"></span><br><span class="line">var obj1 = {}</span><br><span class="line"></span><br><span class="line">var obj2 = {}</span><br><span class="line">var obj3 = JSON.parse(JSON.stringify(obj))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>深拷贝的一些方法</p>
</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function clone(target,source){</span><br><span class="line">  // 获取对象的所有的属性，包括不可遍历的属性</span><br><span class="line">  var names = Object.getOwnPropertyNames(source);</span><br><span class="line">  for (var i=0;i&lt;names.length;i++ ){</span><br><span class="line">    var desc = Object.getOwnPropertyDescriptor(source,names[i])</span><br><span class="line">    if(typeof(desc.value) == "object" &amp; desc.value != null){</span><br><span class="line">      var obj;</span><br><span class="line">      if (Array.isArray(desc.value)) {</span><br><span class="line">        obj = []</span><br><span class="line">      } else {</span><br><span class="line">        obj = {}</span><br><span class="line">      }</span><br><span class="line">      Object.defineProperty(target.names[i],{</span><br><span class="line">        configurable:desc.configurable,</span><br><span class="line">        enumerable:desc.enumerable,</span><br><span class="line">        value:obj.value,</span><br><span class="line">        writable:desc.writable</span><br><span class="line">      });</span><br><span class="line">      clone(obj,desc.value)</span><br><span class="line">    } else {</span><br><span class="line">      Object.defineProperty(target.names[i],{</span><br><span class="line">        // configurable 属性表示不可删除、</span><br><span class="line">        configurable:desc.configurable,</span><br><span class="line">        // enumerable 表示是否可以遍历</span><br><span class="line">        enumerable:desc.enumerable,</span><br><span class="line">        // 值</span><br><span class="line">        value:desc.value,</span><br><span class="line">        // 是否可写</span><br><span class="line">        writable:desc.writable</span><br><span class="line">      });</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h4 id="15-了解一下es6的代理Proxy"><a href="#15-了解一下es6的代理Proxy" class="headerlink" title="15. 了解一下es6的代理Proxy"></a>15. 了解一下es6的代理Proxy</h4><ol>
<li><p>代理使得一个对象拥有了相关的属性和方法：</p>
</li>
<li><p>用法：var p = new Proxy(obj,handler)使得我们的obj对象拥有了handler的一些属性和方法；</p>
</li>
<li><p>简单来说 代理就是给我们的被代理对象添加一些属性和方法，但是是作用在代理实例化对象上，而不是原被代理对象上</p>
</li>
</ol>
  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let obj = {a:1,b:2}</span><br><span class="line"></span><br><span class="line">let handler = {</span><br><span class="line">  set:function(target,key,value){</span><br><span class="line">    target[key] = value</span><br><span class="line">  },</span><br><span class="line">  get:function(target,key){</span><br><span class="line">    return target[key]</span><br><span class="line">  },</span><br><span class="line">  has:function(target,key){</span><br><span class="line">    return key in target;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var p = new Proxy(obj,handler)</span><br><span class="line">p.a = 20;</span><br><span class="line">console.log(obj.p)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h4 id="16-两个加载完成事件的区别"><a href="#16-两个加载完成事件的区别" class="headerlink" title="16. 两个加载完成事件的区别"></a>16. 两个加载完成事件的区别</h4><ol>
<li><p>$(window).load()和$(window).ready()两个加载完成事件的区别</p>
</li>
<li><p>document文档加载的顺序：</p>
<ul>
<li>html结构加载</li>
<li>加载外部样式表和执行文件</li>
<li>加载并解析执行脚本代码</li>
<li>构造dom模型（样式应用）此时ready事件触发</li>
<li>加载图片文件等等资源</li>
<li>再页面加载完成 此时load事件触发</li>
</ul>
</li>
<li><p>ready不必等图片媒体进来之前就可以运行代码了，否则load需要等到全部完成后执行；</p>
</li>
</ol>
<h4 id="17-事件循环Eventloop"><a href="#17-事件循环Eventloop" class="headerlink" title="17. 事件循环Eventloop"></a>17. 事件循环Eventloop</h4><ol>
<li>js任务分为同步任务和异步任务，异步任务主要有宏任务，微任务</li>
<li>js</li>
</ol>
<h3 id="二、nodejs和项目工程化"><a href="#二、nodejs和项目工程化" class="headerlink" title="二、nodejs和项目工程化"></a>二、nodejs和项目工程化</h3><h4 id="1-使用nodejs编写代码实现遍历文件夹及所有文件名"><a href="#1-使用nodejs编写代码实现遍历文件夹及所有文件名" class="headerlink" title="1. 使用nodejs编写代码实现遍历文件夹及所有文件名"></a>1. 使用nodejs编写代码实现遍历文件夹及所有文件名</h4><h4 id="2-node如何做版本的升级？为什么要做nvm"><a href="#2-node如何做版本的升级？为什么要做nvm" class="headerlink" title="2. node如何做版本的升级？为什么要做nvm"></a>2. node如何做版本的升级？为什么要做nvm</h4><h4 id="3-模块化差异，AMD-CMD-Commonjs-Esmodule"><a href="#3-模块化差异，AMD-CMD-Commonjs-Esmodule" class="headerlink" title="3. 模块化差异，AMD,CMD,Commonjs,Esmodule,"></a>3. 模块化差异，AMD,CMD,Commonjs,Esmodule,</h4><h4 id="4-图片上传到服务器的过程-filereader，readAsDataURL"><a href="#4-图片上传到服务器的过程-filereader，readAsDataURL" class="headerlink" title="4. 图片上传到服务器的过程(filereader，readAsDataURL)"></a>4. 图片上传到服务器的过程(filereader，readAsDataURL)</h4><h4 id="5-token如何存在localstorage里面，过期怎么处理"><a href="#5-token如何存在localstorage里面，过期怎么处理" class="headerlink" title="5.  token如何存在localstorage里面，过期怎么处理"></a>5.  token如何存在localstorage里面，过期怎么处理</h4><h4 id="6-node框架中的mvc"><a href="#6-node框架中的mvc" class="headerlink" title="6.  node框架中的mvc"></a>6.  node框架中的mvc</h4><h4 id="7-mongodb和mysql的优势"><a href="#7-mongodb和mysql的优势" class="headerlink" title="7. mongodb和mysql的优势"></a>7. mongodb和mysql的优势</h4><h4 id="8-less-js-sass-ruby-stylus-css-命名空间与css-module"><a href="#8-less-js-sass-ruby-stylus-css-命名空间与css-module" class="headerlink" title="8. less(js) ,sass(ruby),stylus,css,命名空间与css module"></a>8. less(js) ,sass(ruby),stylus,css,命名空间与css module</h4><h4 id="9-工程化上的按需加载"><a href="#9-工程化上的按需加载" class="headerlink" title="9.  工程化上的按需加载"></a>9.  工程化上的按需加载</h4><h4 id="10-git上的冲突怎么解决"><a href="#10-git上的冲突怎么解决" class="headerlink" title="10. git上的冲突怎么解决"></a>10. git上的冲突怎么解决</h4><h4 id="11-设计模式"><a href="#11-设计模式" class="headerlink" title="11. 设计模式"></a>11. 设计模式</h4><h4 id="12-node中的npm版本管理，package-lock和yarn-lock"><a href="#12-node中的npm版本管理，package-lock和yarn-lock" class="headerlink" title="12. node中的npm版本管理，package.lock和yarn.lock"></a>12. node中的npm版本管理，package.lock和yarn.lock</h4><h4 id="13-Webpack"><a href="#13-Webpack" class="headerlink" title="13. Webpack"></a>13. Webpack</h4><h4 id="14-后端的环境的搭建"><a href="#14-后端的环境的搭建" class="headerlink" title="14. 后端的环境的搭建"></a>14. 后端的环境的搭建</h4><h4 id="15-typescript"><a href="#15-typescript" class="headerlink" title="15. typescript"></a>15. typescript</h4><h3 id="二、Vue相关"><a href="#二、Vue相关" class="headerlink" title="二、Vue相关"></a>二、Vue相关</h3><h4 id="axios是什么，如何实现登录功能的"><a href="#axios是什么，如何实现登录功能的" class="headerlink" title="axios是什么，如何实现登录功能的"></a>axios是什么，如何实现登录功能的</h4><ol>
<li>通过axios的请求拦截器interceptors完成request、response拦截</li>
</ol>
<h4 id="vuex统一状态管理"><a href="#vuex统一状态管理" class="headerlink" title="vuex统一状态管理"></a>vuex统一状态管理</h4></div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2021/03/17/img%E7%9A%84%E4%B8%8A%E4%BC%A0%E3%80%81%E9%A2%84%E8%A7%88%E5%92%8CFileReader%E7%B1%BB/" title="img的上传、预览和FileReader类" class="prev">上一篇</a><a href="/2021/03/13/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E5%BC%95%E7%94%A8/" title="第三方模块引用" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2021 <a target="_blank">xiangyou fu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>